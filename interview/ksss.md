---
layout: page
title: 栗原勇樹さんインタビュー
permalink: /interview/ksss/
---

{% include interview-head github='ksss' %}

5/13 株式会社spice lifeにて伺いました（話し手：栗原さん、聞き手：笹田）。

__栗原__ 実は、だいたいスライドが出来てまして。

__笹田__ え、本当ですか。素晴らしい。今回のご発表は、type_struct という gem を作られた経験から、Ruby の型に対する提言を頂ける、という感じになるでしょうか。

__栗原__ Ruby の型に対する、みたいな話は、あまり言えないかもしれません。あまり言うと怖い人に怒られるかも。

__笹田__ 以前、[type_struct gem](https://rubygems.org/gems/type_struct) を、[Ruby のバグトラッカーで紹介](https://bugs.ruby-lang.org/issues/11925#note-1) されていましたよね。たしか、`Struct#new` にキーワード引数で値を渡したい、という要望だったと思います。

__栗原__ はい。まさに同じことをやろうとしました。ついでに、型をつける書き方がいいかと思って、遊び心で入れてみた、という次第です。でも、作ったけど使わなかったんですよね。`Struct` のままでいいじゃん、となって。

__笹田__ なるほど。

__栗原__ ただ、次に JSON を扱いだしたとき、全部 Hash になってしまうので、`json['foo']['bar']` のように書くのが非常に面倒だなと思いまして。タイポしても気づきづらいですし。なので、`json.foo.bar` のようにアクセスしたいなと。別の言語、Go や Crystal には、Struct を定義しておくと、JSON から、その型のオブジェクトが取れる、という機能があるので、それを作ろうと。

__笹田__ 型を指定するのと、メソッド呼び出しで書ける、というのは別々の話いですよね？

__栗原__ はい。その二つを組み合わせると良いかと思いまして。そこで、こういうふうに書けるようにしました。間違えた名前があるとエラーになるので、わかりやすくなったと思います。

```
Point = TypeStruct.new{
  x: Integer,
  y: Integer,
}
Line = TypeStruct.new{
  p1: Point,
  p2: Point,
}
hash = JSON.parse(%({"p1":{"x":3,"y":10},"p2":{"x":5,"y":9}}))
line = Line.from_hash(hash)
p line.p2.y #=> 9
```

__笹田__ ハッシュ値を、この TypeStruct の構造体に変換するんでしょうか。

__栗原__ はい。JSON でも YAML でも対応したいと思いまして。

__笹田__ どうやって型とマッチさせるんですか？

__栗原__ メンバーのキー名の一致と、値の `===` でマッチできれば、それを変換するようにします。例えば、`Point.from_hash({x: 1, y: 2})` とすると、`x`、`y` というメンバがあり、`Integer === 1`、`Integer === 2` がマッチするので、hashからPointのインスタンスに変換できます。

__笹田__ 必要なメンバが足りない時はどうなるんでしょう。

__栗原__ メンバーが足りなければエラーになります。逆に、増えた場合、例えば、`{x: 1, y: 2, z: 3}` の場合は、マッチして、単に `z` を無視します。

__笹田__ `===` でマッチはするが、`from_hash` のようなメソッドを持たないクラス（型）を指定した場合はどうなるんでしょうか。

__栗原__ うまくいきません。そこは自己責任ということで。

__笹田__ なるほど。

__栗原__ だいたいうまいこと行くのですが、いくつか問題がありました。まずは、`Array` です。型として `Array` を指定することはできるのですが、そのArrayの中身の型が指定できないのです。そこで、`ArrayOf(type)` というものを導入しました。これで中身の型を指定することができます。また、同じように、`HashOf(type)` というものもサポートしています。

```
Bar = TypeStruct.new(
  baz: TypeStruct::ArrayOf.new(Integer),
)
p Bar.new(baz: [1, 2, 3]) #=> #<Bar baz=[1, 2, 3]>
```

__笹田__ なるほど。

__栗原__ それから、`Boolean` と `nil` がくせ者です。`true` か `false` をマッチさせられて、`===` の左辺に置けるものが Ruby にはないんですよね。TrueClassとFalseClassにBoolean moduleをincludeして判別しているライブラリもあります。

また、`nil` を許すかどうかは、他の言語でも、色々な考え方があるようです。CやGolangでははじめから`nil`を許していますが、Crystalだと`nil`はデフォルトでは許しておらず、`String | Nil`のようにオプションで許可しなければなりません。

__笹田__ なるほど。

__栗原__ 問題を一般化すると複数の型をゆるすものだと考え、解決策としてUnion classを作りました。指定された型のうち、どれか一つにマッチすればOKというものです。

これなら「TrueClassもしくはFalseClassにマッチするもの」とすればいわゆるBooleanが作れますし、「何かのclassもしくはNilClassにまっちするもの」とすればnilがありえることを定義できます。ArrayOfなどと組み合わせて「FooもしくはBarもしくはBazの配列」も定義できます。

```
Aaa = TypeStruct.new(
  foo: TypeStruct::Union.new(TrueClass, FalseClass),
  bar: TrueClass | FalseClass # refinementsによるTypStruct::Union.newの省略記法
  baz: Baz | NilClass,
  qux: ArrayOf(Foo | Bar | Baz)
)
```

__栗原__ その他にも、実験作としてInterfaceもあります。Ruby だと duck typing がしたい、というのがあります。あるメソッドを持っているものでマッチするようなものを書けるようにしました。

```
Foo = TypeStruct.new(
  bar: TypeStruct::Interface.new(:read, :write)
)
Foo.new(bar: $stdin)
Foo.new(bar: 1) #=> TypeError
```

__笹田__ 色々ありますね。

__笹田__ Unionの場合、複数の型がマッチするような場合はどうなるんですか？

__栗原__ それは直面した問題です。Unionに設定されているいずれかの型がマッチすればその型で変換を試みるのですが、これだと最初にマッチしたものになってしまうので曖昧さがありますし、もし型が間違っていたとき、どこが本当に間違いなのかわかりづらくデバッグもしづらいです。Crystal だと、JSON に対してUnion型を指定するのはサポートしていません ([JSON mapping, mixed type array #1061](https://github.com/crystal-lang/crystal/issues/1061))。あつかいが難しいのかな、と。Union が本当にデメリットよりメリットが大きいのか、まだ答えは出ていません。現在ではデバッグ用の出力をリッチにするという方法で逃げています。

__笹田__ で、Ruby 3 の話につながる感じですか。

__栗原__ 笹田さんの以前の発表 『[MRI Internals](http://www.atdot.net/~ko1/activities/2016_RubyConfLT_pub.pdf)』(PDF)  を引いたり、他の言語からヒントが得られないか、検討しようと思っています。例えば、JavaScript ですと、後付けで型を付ける文化があると思うのですが、そういうのを調べようと思います。

__笹田__ Ruby に型があると（型を書くと）便利だと思いますか？

__栗原__ 便利は便利だと思います。実際に仕事でも使っているのですが、新人に「この JSON はどういう構造がありえるんですか？」と聞かれた時に「ここに型定義がまとまっているよ」とドキュメント的に示すことができます。書いていても安心感がある。

ですが、色々考えないといけないことがあると思っています。そういえば、Ruby 3 が目標としているのは、事前の静的なチェックですよね。

__笹田__ はい。ただ、まつもとさんが型を書かせたくない（書きたくない）、と言っているのがどうなるのかな、と。組込みのCで書かれたメソッドには（処理系開発者ががんばって）型を書く分には問題無いけど、とは言ってました。

__栗原__ あ、そこが一番問題だと思っていました。それが解決できるのはいいですね。(大変そうだな……)

__笹田__ Crystal は、そういう情報から、すべて推論すると思います。しかし、空の配列などには型を書かないといけないんですよね。まつもとさんは、そこが気に入らないらしい。

__栗原__ 型を書きたくないなら、というアイデアがあって、最初は型が決まらない状態から初めて、最初にきたものは許すけど、二度目からは、その型しか許さない、というようなものを作ってみました。[GuessStruct](https://github.com/ksss/guess_struct)。使ってはいないのですが。

__笹田__ 同じようなアイデアで、テストできた型以外は弾く、というのはどうだろう、というアイデアがありました。テストが型だ、みたいな。ただ、テスト書く方が長いという。

__栗原__ まつもとさんは、テストも書きたくないって言ってましたよね。

__笹田__ 言ってました。

__栗原__ やはり、型が書けると、開発時に便利だと思いますね。

__笹田__ わかります。ぜひ、まつもとさんを説得して下さい。

__栗原__ 「型書いてもいいじゃないですか」って。

__笹田__ 今日は、お忙しい中ありがとうございました。
