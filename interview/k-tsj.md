---
layout: page
title: 辻本和樹さんインタビュー
permalink: /interview/k-tsj/
---

{% include interview-head github='k-tsj' %}

5/15 チャットにて伺いました（話し手：辻本さん、聞き手：笹田）。

__笹田__ お忙しい中、お時間をとって頂いてありがとうございます。今回のご発表は、Ruby におけるパターンマッチの実装ということで、[patten-match gem](https://github.com/k-tsj/pattern-match) のお話ということですが、以前、ご発表されていませんでしたっけ。

__辻本__ [札幌 Ruby 会議 2012](http://sapporo.rubykaigi.org/2012/ja/schedule/details/11.html)ですね。

__笹田__ GitHub を見ると、最後の更新が 2015 年。

__辻本__ 一通り実装したい機能は実装しちゃったんですよね。札幌での発表のときは正規表現相当のマッチは出来なかったんですが、その後にサポートしました。あと、バックトラックもかな。機能面については札幌での発表であらかたカバーしているので、実装の仕方を主眼に発表しようと考えています。加えて、ちらほらpattern-matchを使っている事例が出てきているのでその紹介とか。

## pattern-match gem の紹介

__笹田__ では、pattern-match gem について、ご紹介頂けないでしょうか。

__辻本__ はい。[https://github.com/k-tsj/pattern-match#pattern-match](https://github.com/k-tsj/pattern-match#pattern-match) を読んで頂くのが一番はやいですが、主に、`match` と `with` というメソッドで、パターンマッチを書くことができます。このとき、普通の `case`/`when` に比べて、

1. マッチの条件につかうことができる表現を拡張した（`===` 以外を許す、`and`/`or`/`not`、`Quantifier`、`Sequence`、ガード）
2. マッチしたときに、オブジェクトの情報を解体し、その情報を使って処理が出来るようにした（`deconstruct` メソッドというプロトコルを定義した）

というものになります。

__笹田__ 具体的には、マッチはどんなふうにされるんでしょうか。

__辻本__ 基本は `===` でマッチしますが、`_(Fixnum, :==)` のように、マッチのためのメソッドを変更することができます。

__笹田__ なるほど。マッチするところは、`case`/`when` と大きな違いはないんですね。

__辻本__ はい。そこは`case`/`when` に合わせました。

__笹田__ で、次は解体（deconstruct）ですが、[https://github.com/k-tsj/pattern-match#deconstructor](https://github.com/k-tsj/pattern-match#deconstructor) を見ているのですが、よくわかりません。普通に `[0, 1]` とマッチさせるのと何が違うんでしょうか。

__辻本__ これは、次の [Variable](https://github.com/k-tsj/pattern-match#variable) のところと一緒に見てもらうとわかります。

```
match([0, 1]) do
  with(_[a, b]) { [a, b] } #=> [0, 1]
end
```

このように書くと、`a, b` に、マッチした `0` と `1` がそれぞれ割り当てられて、使うことができます。

__笹田__ `method_missing` で無理矢理やってる感じですか。

__辻本__ その通りです。`match` に渡したブロックは `BasicObject.new.instance_eval` のコンテキストで評価されて、`method_missing` で未定義のメソッドはすべて変数扱いにしています。どのように分解するか、はクラス (オブジェクト) ごとに `deconstruct` メソッドで決めます。

__笹田__ `_` が色々出てきますね。

__辻本__ はい、いろいろ意味を持たせてしまっています。今は3つですね。このうち、`Array.()` のシンタックスシュガー扱いとしている `_[]` はリテラルの `[]` との違いが分かりづらく典型的な落とし穴になっています。例えば、[https://github.com/k-tsj/pattern-match/issues/3](https://github.com/k-tsj/pattern-match/issues/3)

__笹田__ マッチの条件では、`and` や `or` が使える、と。色々リッチになっていますね。

__辻本__ はい。`&` とか `|` は [Scheme のパターンマッチライブラリ](http://practical-scheme.net/gauche/man/gauche-refj_203.html) の影響を受けています 。正規表現は Mathematcia 由来といえるのかな (あまり Mathematica 知らないので適当ですが)。

__笹田__ deconstruct について、もう少し教えて貰えますか。クラスごとに、いろんな選択肢があると思うのですが、例えば、`class Foo; attr :bar, :baz; end` というクラスがあったとき、`foo.bar` が配列で、その3要素目、とかを取り出したい、みたいなのも書けますか。

__辻本__ ちょっと `Foo` の例を書いてみます。

```
def Foo.deconstruct(obj)
  accept_self_instance_only(obj)
  [obj.bar, obj.baz]
end
```

Deconstructはこれだけ。とりあえず自身を分解して配列で返せば OK です。
その上で、`match(foo){with(Foo.(_[_,_,a], _))` とやってマッチさせます。

__笹田__ baz, bar の順序でマッチさせたくても駄目でしょうか。名前の情報が落ちているので。

__辻本__ それはだめですね。

__笹田__ インスタンス変数だと、順番覚えろ、はつらいような気がします。

__辻本__ そこで、こういうことが出来るようにしてはいます。

```
class Foo
  include PatternMatch::AttributeMatcher
end
match(foo) do
  with(Foo.(bar: _[_,_,a])) { a }
end
```

__笹田__ `Hash` も同じように順番を区別しないでできるようですが、これらは頑張って matcher 書いてる感じですか。

__辻本__ そうですね。単純な deconstruct より一段上のレベルでの matcher です。

__笹田__ Deconstruct のプロトコルが難しそうですが、このアイデアはご自身で考えられたんですか？

__辻本__ 今のプロトコルは Scala の unapply という仕組みを割とそのまま持ってきていて、あまり独自のことは考えていません。ただ、現状の仕様で、自分の使う範囲では、今の機能で困ったことはないですね。

## pattern-match gem の実装と Ruby への輸入

__笹田__ ありがとうございました。gem の使い方について、だいたいわかった気がします。さらに、これをどうやって実装するのか、というのは、あまり考えたくないですが。現在は Ruby の機能だけで作っているんですよね。「Ruby 拡張してインタプリタいじったほうが簡単そう！」という印象です。実装するにあたって、Ruby の機能に不足はありませんでしたか。

__辻本__ はい、裏側を見ると分かるのですがかなり無理矢理動かしている感があるので本体に機能が入るとうれしいなと思っています。文法的には、つまり見た目としては、今ので結構満足しています。Ruby と同じくオブジェクト指向言語でパターンマッチを持っている Scala のそれと比べてもそんなに違和感なく、書くのもつらくない。

__笹田__ `case`/`when` の拡張みたいな話にはならないんでしょうか。

__辻本__ [shugo さんもそんな提案](https://shugo.net/jit/20120309.html) をされていたはずです。この gem は proof of concept の域を出ないので、Ruby 自体にこの機能を持って行くにしても、今のアルゴリズムはそのままでは移植できないと思います。

__笹田__ ちなみに、この gem、実際使ってます？

__辻本__ power_assert の初期実装では便利に使っていました。

__笹田__ 今は使ってないんですか。

__辻本__ はい。当時は pattern-match が refinements 使っていなかったこともあって Rack の `#call` とバッティングするなどの問題があったので。

__笹田__ 実装的な問題があったんですね。

__辻本__ あとやっぱり遅いですね。最近まじめに power_assert の高速化をしていたんですが、TracePoint のイベント呼び出しだけで 3 倍とか時間かかるので…。

__笹田__ この機能を Ruby 本体に入れる、という話ですと、まつもとさんへの説得材料って揃ってますかね？

__辻本__ 一言で言うと、無くは無いがまだ弱い、というところかなと。ユースケースを示すことが大事だと思うんですが、実際の使われ方を見ていると結局構文解析とか、ごく限られた領域にとどまっているんですよね。Rails で頻出のこのパターンが便利に書ける、みたいなのがあれば通しやすいのでしょうけど。

__笹田__ それは、知名度の問題じゃないのかな？

__辻本__ それも大いにあるかもしれません。

__笹田__ こういうのを知っている人は、たいてい構文解析とかやりたい人達だ、とか。パターンマッチがあれば、例えば、インスタンス変数の分解とか、さっとやりたい、ってのはあると思います。他の例だと、今だと、ハッシュの key、 a, b に対する要素をとるのに2行かかりますが、これを使うと、1行で（match いれると2行か）いける、とか。

__辻本__ Hash は、[別の提案](https://bugs.ruby-lang.org/issues/6414)がありますね。 

__笹田__ パターンマッチに一般化したほうが綺麗だと思うんだけど。

__辻本__ はい、私もそう思います。

__笹田__ いろんな方法がありますよね。(1) `case`/`when` を拡張する (2) 多重代入を拡張する (3) `=~` を拡張する (4) それらを混ぜる。

__辻本__ あと、本体に入れるにしてもパターンマッチそのもので無く、パターンマッチを実装できるプリミティブを入れるという考え方もあって。真っ先に思いつくのはマクロですが、そこまで行かなくてもなんかないかなぁとか。

__笹田__ マクロはないんじゃないですかね（まつもとさんが嫌がりそう）。

__辻本__ 実際マクロはないでしょうね。

__笹田__ 個人的には、パターンマッチのある言語をがっつり使ったことは無いのですが、あると便利そうだなぁ、とは思います。ぜひ東京 Ruby 会議 11 でまつもとさんを説得して下さい。彼も、欲しいと言っていたと思います。

__辻本__ 頑張ります。

__笹田__ では、今日はどうもありがとうございました。
